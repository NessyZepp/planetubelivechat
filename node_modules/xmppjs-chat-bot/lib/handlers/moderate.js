"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerModerate = void 0;
const abstract_1 = require("./abstract");
const handlers_directory_1 = require("../handlers_directory");
class HandlerModerate extends abstract_1.Handler {
    constructor(id, room, options) {
        super(id, room, options);
        this.rules ?? (this.rules = []);
        this.applyToModerators ?? (this.applyToModerators = false);
        this.roomMessage = (stanza, fromUser) => {
            const body = stanza.body()?.toString() ?? '';
            if (!body.length) {
                return;
            }
            for (const rule of this.rules) {
                const regexps = Array.isArray(rule.regexp) ? rule.regexp : [rule.regexp];
                for (const regexp of regexps) {
                    if (regexp.test(body)) {
                        this.logger.debug('Message match following rule: ' + rule.name);
                        if (!this.applyToModerators && fromUser.isModerator()) {
                            this.logger.debug('Ignoring the moderation rule ' + rule.name + ', because the user is moderator.');
                            continue;
                        }
                        this.room.moderateMessage(stanza, rule.reason).catch((err) => { this.logger.error(err); });
                        return;
                    }
                }
            }
        };
    }
    loadOptions(options) {
        if (typeof options !== 'object') {
            return;
        }
        if (('applyToModerators' in options) && (typeof options.applyToModerators === 'boolean')) {
            this.applyToModerators = options.applyToModerators;
        }
        if (!('rules' in options)) {
            return;
        }
        let rules = options.rules;
        this.rules = [];
        if (!Array.isArray(rules)) {
            if (typeof rules === 'string') {
                rules = new RegExp(rules, 'i');
            }
            if (!(rules instanceof RegExp)) {
                throw new Error('Invalid rules options');
            }
            this.rules.push({
                name: rules.toString(),
                regexp: rules
            });
        }
        else {
            for (let rule of rules) {
                if (typeof rule === 'string') {
                    rule = new RegExp(rule, 'i');
                }
                if (rule instanceof RegExp) {
                    this.rules.push({
                        name: rule.toString(),
                        regexp: rule
                    });
                }
                else if ((typeof rule === 'object') && rule.name && rule.regexp) {
                    const modifiers = (typeof rule.modifiers === 'string') ? rule.modifiers : undefined;
                    this.rules.push({
                        name: rule.name,
                        regexp: ((typeof rule.regexp === 'string') || modifiers !== undefined)
                            ? new RegExp(rule.regexp, modifiers ?? 'i')
                            : rule.regexp,
                        reason: rule.reason
                    });
                }
                else {
                    throw new Error('Invalid rule value');
                }
            }
        }
    }
    start() {
        this.room.on('room_message', this.roomMessage);
    }
    stop() {
        this.room.off('room_message', this.roomMessage);
    }
}
exports.HandlerModerate = HandlerModerate;
handlers_directory_1.HandlersDirectory.singleton().register('moderate', HandlerModerate);
//# sourceMappingURL=moderate.js.map