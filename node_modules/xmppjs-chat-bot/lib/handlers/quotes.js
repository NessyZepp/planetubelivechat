"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerRandomQuotes = exports.HandlerQuotes = exports.HandlerQuotesBase = void 0;
const abstract_1 = require("./abstract");
const handlers_directory_1 = require("../handlers_directory");
const DEFAULT_DELAY_SECONDS = 10;
class HandlerQuotesBase extends abstract_1.Handler {
    constructor(id, room, options) {
        super(id, room, options);
        this.quotes ?? (this.quotes = []);
        this.quoteDelay ?? (this.quoteDelay = DEFAULT_DELAY_SECONDS * 1000);
    }
    loadOptions(options) {
        if (typeof options !== 'object') {
            return;
        }
        if (('quotes' in options) && (Array.isArray(options.quotes))) {
            this.quotes = [];
            for (const q of options.quotes) {
                if (typeof q === 'string') {
                    this.quotes.push(q);
                }
            }
        }
        if (('delay' in options) && (options.delay === undefined || (typeof options.delay === 'number'))) {
            const newDelay = (options.delay ?? DEFAULT_DELAY_SECONDS) * 1000;
            if (this.quoteDelay !== newDelay) {
                this.quoteDelay = newDelay;
                if (this.timeout) {
                    this.logger.info('The quote delay has changed, we must stop and start the handler again');
                    this.stop();
                    this.start();
                }
            }
        }
    }
    start() {
        if (this.timeout) {
            this.stop();
        }
        this.timeout = setInterval(() => {
            this.sendQuote();
        }, this.quoteDelay);
    }
    stop() {
        if (this.timeout) {
            clearInterval(this.timeout);
            this.timeout = undefined;
        }
    }
    sendQuote() {
        const room = this.room;
        if (!room.isOnline()) {
            this.logger.debug('[HandlerQuote] The room ' + this.room.jid.toString() + ' is not online, skipping.');
            return;
        }
        const onlineUserCount = this.room.onlineUserCount();
        this.logger.debug(`[HandlerQuote] Online user count in room: ${onlineUserCount}`);
        if (onlineUserCount < 2) {
            return;
        }
        const txt = this.getQuoteTxt();
        if (!txt) {
            return;
        }
        this.room.sendGroupchat(txt).catch((err) => { this.logger.error(err); });
    }
}
exports.HandlerQuotesBase = HandlerQuotesBase;
class HandlerQuotes extends HandlerQuotesBase {
    constructor() {
        super(...arguments);
        this.count = 0;
    }
    getQuoteTxt() {
        this.logger.info(`Emitting the message number ${this.count}.`);
        return this.quotes[(this.count++) % this.quotes.length];
    }
}
exports.HandlerQuotes = HandlerQuotes;
class HandlerRandomQuotes extends HandlerQuotesBase {
    getQuoteTxt() {
        const count = Math.round(Math.random() * (this.quotes.length - 1));
        if (count >= this.quotes.length) {
            return null;
        }
        this.logger.info(`Emitting the random message number ${count}.`);
        return this.quotes[count];
    }
}
exports.HandlerRandomQuotes = HandlerRandomQuotes;
handlers_directory_1.HandlersDirectory.singleton().register('quotes', HandlerQuotes);
handlers_directory_1.HandlersDirectory.singleton().register('quotes_random', HandlerRandomQuotes);
//# sourceMappingURL=quotes.js.map