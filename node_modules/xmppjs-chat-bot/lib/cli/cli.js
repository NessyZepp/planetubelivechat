#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const read_1 = require("../config/read");
const handlers_directory_1 = require("../handlers_directory");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const signals = ['SIGHUP', 'SIGINT', 'SIGQUIT', 'SIGILL', 'SIGTRAP', 'SIGABRT',
    'SIGBUS', 'SIGFPE', 'SIGUSR1', 'SIGSEGV', 'SIGUSR2', 'SIGTERM'];
const version = require('../../package.json').version;
const program = new commander_1.Command();
program
    .version(version, '-v --version')
    .usage('[command] [options]')
    .showHelpAfterError();
const runCommand = program.command('run');
runCommand.description('Read one or more config files and execute the corresponding bot.');
runCommand.requiredOption('-f, --file <files...>', 'one or more JSON files to parse');
runCommand.option('--room-conf-dir <directories...>', 'a directory containing room configuration JSON files');
runCommand.option('--load-handlers <files...>', 'one or more external handler to load. Files must be Javascript modules, ' +
    'exporting a "registerHandlers" function. See documentation for more information.');
runCommand.option('-d, --debug', 'force the use @xmpp/debug');
runCommand.option('-l, --log-level <level>', 'set the log level');
runCommand.action(async (options) => {
    if (options.loadHandlers && options.loadHandlers.length > 0) {
        console.log('Loading additional handlers...');
        for (const handlersFilePath of options.loadHandlers) {
            await handlers_directory_1.HandlersDirectory.singleton().registerFromFile(handlersFilePath);
        }
    }
    console.log('Loading config files...');
    const bots = new Map();
    signals.forEach((sig) => {
        process.on(sig, () => {
            console.info('Receiving signal: ' + sig);
            console.info('Shutdown...');
            const promises = [];
            bots.forEach(bot => {
                console.info('Stopping the bot ' + bot.botName + '...');
                const p = new Promise(resolve => {
                    bot.disconnect().then(() => { }, (err) => {
                        console.error(`Error when stopping the bot ${bot.botName}: ${err}`);
                    }).finally(() => resolve());
                });
                promises.push(p);
            });
            bots.clear();
            console.info('Waiting all bots to disconnect...');
            Promise.all(promises).then(() => { }, () => { }).finally(() => {
                console.info('We can now exit.');
                process.exit();
            });
            setTimeout(() => {
                console.error('It seems the bots have not disconnected within 1000ms, exiting anyway.');
                process.exit(1);
            }, 1000);
        });
    });
    async function loadFile(filePath) {
        if (bots.has(filePath)) {
            console.info(`File ${filePath} is already loaded, unloading...`);
            const bot = bots.get(filePath);
            await bot?.disconnect();
            bots.delete(filePath);
        }
        if (!fs_1.default.existsSync(filePath)) {
            console.error(`File '${filePath} not found, skipping...`);
            return;
        }
        try {
            const content = fs_1.default.readFileSync(filePath, { encoding: 'utf8' });
            const json = JSON.parse(content);
            if (!json) {
                console.error(`File ${filePath} seems to be empty.`);
                return;
            }
            if (typeof json !== 'object') {
                console.error(`File ${filePath} dont seem to contain a json object`);
                return;
            }
            if (options.debug) {
                json.debug = true;
            }
            if (options.logLevel) {
                json.log_level = options.logLevel;
            }
            const bot = await (0, read_1.getBotFromConfig)(json);
            bots.set(filePath, bot);
        }
        catch (err) {
            console.error(`Error loading the file ${filePath}: ${err}`);
        }
    }
    for (const file of (options.file) ?? []) {
        const filePath = path_1.default.resolve(file);
        await loadFile(filePath);
    }
    if (options.roomConfDir) {
        const dirs = Array.isArray(options.roomConfDir) ? options.roomConfDir : [options.roomConfDir];
        for (const dir of dirs) {
            bots.forEach(bot => {
                bot.waitOnline().then(() => {
                    bot.loadRoomConfDir(dir).then(() => { }, (reason) => console.error(reason));
                }, (reason) => console.error(reason));
            });
        }
    }
});
program.parse(process.argv);
//# sourceMappingURL=cli.js.map