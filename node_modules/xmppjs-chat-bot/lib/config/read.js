"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readRoomConf = exports.getBotFromConfig = void 0;
const client_1 = require("@xmpp/client");
const component_1 = require("@xmpp/component");
const debug_1 = __importDefault(require("@xmpp/debug"));
const bot_1 = require("../bot");
const logger_1 = require("../logger");
const fs_1 = __importDefault(require("fs"));
async function getBotFromConfig(config) {
    if (typeof config === 'string') {
        const filePath = config;
        const content = await fs_1.default.promises.readFile(filePath, { encoding: 'utf8' });
        const json = JSON.parse(content);
        if (!json) {
            throw new Error(`File ${filePath} seems to be empty.`);
        }
        if (typeof json !== 'object') {
            throw new Error(`File ${filePath} dont seem to contain a json object`);
        }
        config = json;
    }
    else {
        config = JSON.parse(JSON.stringify(config));
    }
    if (!config) {
        throw new Error('Missing config');
    }
    if (typeof config !== 'object') {
        throw new Error('Config invalid. Should be an object.');
    }
    let connection;
    if (config.type === 'client') {
        connection = (0, client_1.client)(config.connection);
    }
    else if (config.type === 'component') {
        connection = (0, component_1.component)(config.connection);
    }
    else {
        throw new Error(`Invalid type '${config.type}'`);
    }
    if (config.xmpp_debug) {
        (0, debug_1.default)(connection, true);
    }
    let logger;
    if (config.logger === 'ConsoleLogger') {
        logger = new logger_1.ConsoleLogger();
    }
    else if (config.logger === 'ColorConsoleLogger') {
        logger = new logger_1.ColorConsoleLogger();
    }
    logger ?? (logger = new logger_1.DefaultLogger());
    if (config.log_level &&
        (config.log_level === 'debug' ||
            config.log_level === 'info' ||
            config.log_level === 'warn' ||
            config.log_level === 'error')) {
        logger.setLevel(config.log_level);
    }
    const bot = new bot_1.Bot(config.name ?? 'Bot', connection, logger);
    bot.connect().then(async () => {
        config = config;
        if (!config.rooms) {
            return;
        }
        try {
            if (!Array.isArray(config.rooms)) {
                throw new Error('The room entry must be an array');
            }
            for (const roomConfig of (config.rooms ?? [])) {
                if (!roomConfig.domain || !roomConfig.local) {
                    throw new Error('Invalid room configuration');
                }
                const cleanedRoomConfig = await readRoomConf(roomConfig, logger);
                if (!cleanedRoomConfig) {
                    throw new Error('Invalid room configuration');
                }
                if (config.handlers && Array.isArray(config.handlers) && config.handlers.length) {
                    cleanedRoomConfig.handlers = config.handlers.concat(cleanedRoomConfig.handlers);
                }
                await bot.loadRoomConf(cleanedRoomConfig);
            }
        }
        catch (err) {
            bot.logger.error(err);
        }
    }, (err) => {
        bot.logger.error(err);
    });
    return bot;
}
exports.getBotFromConfig = getBotFromConfig;
async function readRoomConf(config, logger) {
    logger ?? (logger = new logger_1.DefaultLogger());
    logger = (0, logger_1.wrapLogger)('readRoomConf', logger);
    try {
        let o;
        if (typeof config === 'string') {
            const content = await fs_1.default.promises.readFile(config);
            o = JSON.parse(content.toString());
        }
        else {
            o = config;
        }
        if (typeof o !== 'object') {
            logger.error('Config parameter is not an object, can\'t load.');
            return null;
        }
        if (!('local' in o) || !o.local || (typeof o.local !== 'string')) {
            logger.error('Missing local attribute');
            return null;
        }
        const local = o.local;
        if (!('domain' in o) || !(typeof o.domain === 'string')) {
            logger.error('Missing domain attribute');
            return null;
        }
        const domain = o.domain;
        const enabled = !!(o.enabled ?? true);
        const handlers = [];
        let nick;
        if (('nick' in o) && (typeof o.nick === 'string')) {
            nick = o.nick;
        }
        if (('handlers' in o) && Array.isArray(o.handlers)) {
            for (const h of o.handlers) {
                if (!('type' in h) || !(typeof h.type === 'string')) {
                    logger.error('Missing type attribute for handler configuration');
                    continue;
                }
                if (!('id' in h) || !(typeof h.id === 'string')) {
                    logger.error('Missing id attribute for handler configuration');
                    continue;
                }
                const handlerEnabled = !!(h.enabled ?? true);
                const handler = {
                    id: h.id,
                    enabled: handlerEnabled,
                    type: h.type,
                    options: {}
                };
                if ('options' in h) {
                    handler.options = h.options;
                }
                handlers.push(handler);
            }
        }
        return {
            local,
            domain,
            nick,
            enabled,
            handlers
        };
    }
    catch (err) {
        logger.error(err);
        return null;
    }
}
exports.readRoomConf = readRoomConf;
//# sourceMappingURL=read.js.map