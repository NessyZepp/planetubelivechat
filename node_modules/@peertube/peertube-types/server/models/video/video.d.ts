/// <reference types="fluent-ffmpeg" />
import Bluebird from 'bluebird';
import { Transaction } from 'sequelize';
import { Model } from 'sequelize-typescript';
import { ResultList, Video, VideoDetails, VideoFile, VideoInclude, VideoObject, VideoPrivacy, VideoRateType, VideoState } from '../../../shared/models';
import { AttributesOnly } from '../../../shared/typescript-utils';
import { MChannel, MChannelId, MStreamingPlaylist, MStreamingPlaylistFilesVideo, MUserAccountId, MUserId, MVideo, MVideoAccountLight, MVideoAccountLightBlacklistAllFiles, MVideoAP, MVideoDetails, MVideoFileVideo, MVideoFormattable, MVideoFormattableDetails, MVideoForUser, MVideoFullLight, MVideoId, MVideoImmutable, MVideoThumbnail, MVideoThumbnailBlacklist, MVideoWithAllFiles, MVideoWithFile } from '../../types/models';
import { MThumbnail } from '../../types/models/video/thumbnail';
import { MVideoFile, MVideoFileStreamingPlaylistVideo } from '../../types/models/video/video-file';
import { VideoAbuseModel } from '../abuse/video-abuse';
import { AccountVideoRateModel } from '../account/account-video-rate';
import { TrackerModel } from '../server/tracker';
import { UserVideoHistoryModel } from '../user/user-video-history';
import { VideoViewModel } from '../view/video-view';
import { VideoFormattingJSONOptions } from './formatter/video-format-utils';
import { ScheduleVideoUpdateModel } from './schedule-video-update';
import { DisplayOnlyForFollowerOptions } from './sql/video';
import { TagModel } from './tag';
import { ThumbnailModel } from './thumbnail';
import { VideoBlacklistModel } from './video-blacklist';
import { VideoCaptionModel } from './video-caption';
import { VideoChannelModel } from './video-channel';
import { VideoCommentModel } from './video-comment';
import { VideoFileModel } from './video-file';
import { VideoImportModel } from './video-import';
import { VideoJobInfoModel } from './video-job-info';
import { VideoLiveModel } from './video-live';
import { VideoPlaylistElementModel } from './video-playlist-element';
import { VideoShareModel } from './video-share';
import { VideoSourceModel } from './video-source';
import { VideoStreamingPlaylistModel } from './video-streaming-playlist';
export declare enum ScopeNames {
    FOR_API = "FOR_API",
    WITH_ACCOUNT_DETAILS = "WITH_ACCOUNT_DETAILS",
    WITH_TAGS = "WITH_TAGS",
    WITH_WEBTORRENT_FILES = "WITH_WEBTORRENT_FILES",
    WITH_SCHEDULED_UPDATE = "WITH_SCHEDULED_UPDATE",
    WITH_BLACKLISTED = "WITH_BLACKLISTED",
    WITH_STREAMING_PLAYLISTS = "WITH_STREAMING_PLAYLISTS",
    WITH_IMMUTABLE_ATTRIBUTES = "WITH_IMMUTABLE_ATTRIBUTES",
    WITH_USER_HISTORY = "WITH_USER_HISTORY",
    WITH_THUMBNAILS = "WITH_THUMBNAILS"
}
export type ForAPIOptions = {
    ids?: number[];
    videoPlaylistId?: number;
    withAccountBlockerIds?: number[];
};
export declare class VideoModel extends Model<Partial<AttributesOnly<VideoModel>>> {
    uuid: string;
    name: string;
    category: number;
    licence: number;
    language: string;
    privacy: VideoPrivacy;
    nsfw: boolean;
    description: string;
    support: string;
    duration: number;
    views: number;
    likes: number;
    dislikes: number;
    remote: boolean;
    isLive: boolean;
    url: string;
    commentsEnabled: boolean;
    downloadEnabled: boolean;
    waitTranscoding: boolean;
    state: VideoState;
    createdAt: Date;
    updatedAt: Date;
    publishedAt: Date;
    originallyPublishedAt: Date;
    channelId: number;
    VideoChannel: VideoChannelModel;
    Tags: TagModel[];
    Trackers: TrackerModel[];
    Thumbnails: ThumbnailModel[];
    VideoPlaylistElements: VideoPlaylistElementModel[];
    VideoSource: VideoSourceModel;
    VideoAbuses: VideoAbuseModel[];
    VideoFiles: VideoFileModel[];
    VideoStreamingPlaylists: VideoStreamingPlaylistModel[];
    VideoShares: VideoShareModel[];
    AccountVideoRates: AccountVideoRateModel[];
    VideoComments: VideoCommentModel[];
    VideoViews: VideoViewModel[];
    UserVideoHistories: UserVideoHistoryModel[];
    ScheduleVideoUpdate: ScheduleVideoUpdateModel;
    VideoBlacklist: VideoBlacklistModel;
    VideoLive: VideoLiveModel;
    VideoImport: VideoImportModel;
    VideoCaptions: VideoCaptionModel[];
    VideoJobInfo: VideoJobInfoModel;
    static notifyCreate(video: MVideo): void;
    static notifyUpdate(video: MVideo): void;
    static notifyDestroy(video: MVideo): void;
    static sendDelete(instance: MVideoAccountLight, options: {
        transaction: Transaction;
    }): Promise<any>;
    static removeFiles(instance: VideoModel, options: any): Promise<any>;
    static stopLiveIfNeeded(instance: VideoModel): void;
    static invalidateCache(instance: VideoModel): void;
    static saveEssentialDataToAbuses(instance: VideoModel, options: any): Promise<any>;
    static listLocalIds(): Promise<number[]>;
    static listAllAndSharedByActorForOutbox(actorId: number, start: number, count: number): Bluebird<{
        data: VideoModel[];
        total: number;
    }>;
    static listPublishedLiveUUIDs(): Promise<string[]>;
    static listUserVideosForApi(options: {
        accountId: number;
        start: number;
        count: number;
        sort: string;
        channelId?: number;
        isLive?: boolean;
        search?: string;
    }): Promise<{
        data: MVideoForUser[];
        total: number;
    }>;
    static listForApi(options: {
        start: number;
        count: number;
        sort: string;
        nsfw: boolean;
        isLive?: boolean;
        isLocal?: boolean;
        include?: VideoInclude;
        hasFiles?: boolean;
        hasWebtorrentFiles?: boolean;
        hasHLSFiles?: boolean;
        categoryOneOf?: number[];
        licenceOneOf?: number[];
        languageOneOf?: string[];
        tagsOneOf?: string[];
        tagsAllOf?: string[];
        privacyOneOf?: VideoPrivacy[];
        accountId?: number;
        videoChannelId?: number;
        displayOnlyForFollower: DisplayOnlyForFollowerOptions | null;
        videoPlaylistId?: number;
        trendingDays?: number;
        user?: MUserAccountId;
        historyOfUser?: MUserId;
        countVideos?: boolean;
        search?: string;
        excludeAlreadyWatched?: boolean;
    }): Promise<ResultList<VideoModel>>;
    static searchAndPopulateAccountAndServer(options: {
        start: number;
        count: number;
        sort: string;
        nsfw?: boolean;
        isLive?: boolean;
        isLocal?: boolean;
        include?: VideoInclude;
        categoryOneOf?: number[];
        licenceOneOf?: number[];
        languageOneOf?: string[];
        tagsOneOf?: string[];
        tagsAllOf?: string[];
        privacyOneOf?: VideoPrivacy[];
        displayOnlyForFollower: DisplayOnlyForFollowerOptions | null;
        user?: MUserAccountId;
        hasWebtorrentFiles?: boolean;
        hasHLSFiles?: boolean;
        search?: string;
        host?: string;
        startDate?: string;
        endDate?: string;
        originallyPublishedStartDate?: string;
        originallyPublishedEndDate?: string;
        durationMin?: number;
        durationMax?: number;
        uuids?: string[];
        excludeAlreadyWatched?: boolean;
    }): Promise<ResultList<VideoModel>>;
    static countLives(options: {
        remote: boolean;
        mode: 'published' | 'not-ended';
    }): Promise<number>;
    static countVideosUploadedByUserSince(userId: number, since: Date): Promise<number>;
    static countLivesOfAccount(accountId: number): Promise<number>;
    static load(id: number | string, transaction?: Transaction): Promise<MVideoThumbnail>;
    static loadWithBlacklist(id: number | string, transaction?: Transaction): Promise<MVideoThumbnailBlacklist>;
    static loadImmutableAttributes(id: number | string, t?: Transaction): Promise<MVideoImmutable>;
    static loadByUrlImmutableAttributes(url: string, transaction?: Transaction): Promise<MVideoImmutable>;
    static loadOnlyId(id: number | string, transaction?: Transaction): Promise<MVideoId>;
    static loadWithFiles(id: number | string, transaction?: Transaction, logging?: boolean): Promise<MVideoWithAllFiles>;
    static loadByUrl(url: string, transaction?: Transaction): Promise<MVideoThumbnail>;
    static loadByUrlAndPopulateAccount(url: string, transaction?: Transaction): Promise<MVideoAccountLightBlacklistAllFiles>;
    static loadFull(id: number | string, t?: Transaction, userId?: number): Promise<MVideoFullLight>;
    static loadForGetAPI(parameters: {
        id: number | string;
        transaction?: Transaction;
        userId?: number;
    }): Promise<MVideoDetails>;
    static getStats(): Promise<{
        totalLocalVideos: number;
        totalLocalVideoViews: number;
        totalVideos: number;
    }>;
    static incrementViews(id: number, views: number): Promise<[affectedRows: VideoModel[], affectedCount?: number]>;
    static updateRatesOf(videoId: number, type: VideoRateType, count: number, t: Transaction): Promise<[undefined, number]>;
    static syncLocalRates(videoId: number, type: VideoRateType, t: Transaction): Promise<[undefined, number]>;
    static checkVideoHasInstanceFollow(videoId: number, followerActorId: number): Promise<boolean>;
    static bulkUpdateSupportField(ofChannel: MChannel, t: Transaction): Promise<[affectedCount: number]>;
    static getAllIdsFromChannel(videoChannel: MChannelId): Promise<number[]>;
    static getRandomFieldSamples(field: 'category' | 'channelId', threshold: number, count: number): Promise<any[]>;
    static buildTrendingQuery(trendingDays: number): {
        attributes: any[];
        subQuery: boolean;
        model: typeof VideoViewModel;
        required: boolean;
        where: {
            startDate: {
                [x: number]: Date;
            };
        };
    };
    private static getAvailableForApi;
    private static throwIfPrivateIncludeWithoutUser;
    private static throwIfPrivacyOneOfWithoutUser;
    private static isPrivateInclude;
    isBlacklisted(): boolean;
    isBlocked(): boolean;
    getQualityFileBy<T extends MVideoWithFile>(this: T, fun: (files: MVideoFile[], it: (file: MVideoFile) => number) => MVideoFile): (MVideoFile & {
        Video: T;
    }) | (MVideoFile & {
        VideoStreamingPlaylist: MStreamingPlaylist & {
            VideoFiles: MVideoFile[];
        } & {
            Video: T;
        };
    });
    getMaxQualityFile<T extends MVideoWithFile>(this: T): MVideoFileVideo | MVideoFileStreamingPlaylistVideo;
    getMinQualityFile<T extends MVideoWithFile>(this: T): MVideoFileVideo | MVideoFileStreamingPlaylistVideo;
    getWebTorrentFile<T extends MVideoWithFile>(this: T, resolution: number): MVideoFileVideo;
    hasWebTorrentFiles(): boolean;
    addAndSaveThumbnail(thumbnail: MThumbnail, transaction?: Transaction): Promise<void>;
    getMiniature(): ThumbnailModel;
    hasPreview(): boolean;
    getPreview(): ThumbnailModel;
    isOwned(): boolean;
    getWatchStaticPath(): string;
    getEmbedStaticPath(): string;
    getMiniatureStaticPath(): string;
    getPreviewStaticPath(): string;
    toFormattedJSON(this: MVideoFormattable, options?: VideoFormattingJSONOptions): Video;
    toFormattedDetailsJSON(this: MVideoFormattableDetails): VideoDetails;
    getFormattedWebVideoFilesJSON(includeMagnet?: boolean): VideoFile[];
    getFormattedHLSVideoFilesJSON(includeMagnet?: boolean): VideoFile[];
    getFormattedAllVideoFilesJSON(includeMagnet?: boolean): VideoFile[];
    toActivityPubObject(this: MVideoAP): Promise<VideoObject>;
    getTruncatedDescription(): string;
    getAllFiles(): MVideoFile[];
    probeMaxQualityFile(): Promise<{
        width: number;
        height: number;
        ratio: number;
        resolution: number;
        isPortraitMode: boolean;
        audioStream: import("fluent-ffmpeg").FfprobeStream;
        hasAudio: boolean;
        fps: number;
    }>;
    getDescriptionAPIPath(): string;
    getHLSPlaylist(): MStreamingPlaylistFilesVideo;
    setHLSPlaylist(playlist: MStreamingPlaylist): void;
    removeWebTorrentFile(videoFile: MVideoFile, isRedundancy?: boolean): Promise<any[]>;
    removeStreamingPlaylistFiles(streamingPlaylist: MStreamingPlaylist, isRedundancy?: boolean): Promise<void>;
    removeStreamingPlaylistVideoFile(streamingPlaylist: MStreamingPlaylist, videoFile: MVideoFile): Promise<void>;
    removeStreamingPlaylistFile(streamingPlaylist: MStreamingPlaylist, filename: string): Promise<void>;
    isOutdated(): boolean;
    hasPrivacyForFederation(): boolean;
    hasStateForFederation(): boolean;
    isNewVideo(newPrivacy: VideoPrivacy): boolean;
    setAsRefreshed(transaction?: Transaction): Promise<void>;
    requiresAuth(options: {
        urlParamId: string;
        checkBlacklist: boolean;
    }): boolean;
    hasPrivateStaticPath(): boolean;
    setNewState(newState: VideoState, isNewVideo: boolean, transaction: Transaction): Promise<void>;
    getBandwidthBits(this: MVideo, videoFile: MVideoFile): number;
    getTrackerUrls(): string[];
}
//# sourceMappingURL=video.d.ts.map