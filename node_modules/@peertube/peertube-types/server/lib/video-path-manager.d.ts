import { MStreamingPlaylistVideo, MVideo, MVideoFile, MVideoFileStreamingPlaylistVideo, MVideoFileVideo } from '../types/models';
type MakeAvailableCB<T> = (path: string) => Promise<T> | T;
declare class VideoPathManager {
    private static instance;
    private readonly videoFileMutexStore;
    private constructor();
    getFSHLSOutputPath(video: MVideo, filename?: string): string;
    getFSRedundancyVideoFilePath(videoOrPlaylist: MVideo | MStreamingPlaylistVideo, videoFile: MVideoFile): string;
    getFSVideoFileOutputPath(videoOrPlaylist: MVideo | MStreamingPlaylistVideo, videoFile: MVideoFile): string;
    makeAvailableVideoFile<T>(videoFile: MVideoFileVideo | MVideoFileStreamingPlaylistVideo, cb: MakeAvailableCB<T>): Promise<T>;
    makeAvailableResolutionPlaylistFile<T>(videoFile: MVideoFileStreamingPlaylistVideo, cb: MakeAvailableCB<T>): Promise<T>;
    makeAvailablePlaylistFile<T>(playlist: MStreamingPlaylistVideo, filename: string, cb: MakeAvailableCB<T>): Promise<T>;
    lockFiles(videoUUID: string): Promise<import("async-mutex/lib/MutexInterface").default.Releaser>;
    unlockFiles(videoUUID: string): void;
    private makeAvailableFactory;
    private buildTMPDestination;
    static get Instance(): VideoPathManager;
}
export { VideoPathManager };
//# sourceMappingURL=video-path-manager.d.ts.map