import ffmpeg from 'fluent-ffmpeg';
import { AvailableEncoders, EncoderOptionsBuilderParams } from '../models';
type FFmpegLogger = {
    info: (msg: string, obj?: any) => void;
    debug: (msg: string, obj?: any) => void;
    warn: (msg: string, obj?: any) => void;
    error: (msg: string, obj?: any) => void;
};
export interface FFmpegCommandWrapperOptions {
    availableEncoders?: AvailableEncoders;
    profile?: string;
    niceness: number;
    tmpDirectory: string;
    threads: number;
    logger: FFmpegLogger;
    lTags?: {
        tags: string[];
    };
    updateJobProgress?: (progress?: number) => void;
    onEnd?: () => void;
    onError?: (err: Error) => void;
}
export declare class FFmpegCommandWrapper {
    private static supportedEncoders;
    private readonly availableEncoders;
    private readonly profile;
    private readonly niceness;
    private readonly tmpDirectory;
    private readonly threads;
    private readonly logger;
    private readonly lTags;
    private readonly updateJobProgress;
    private readonly onEnd?;
    private readonly onError?;
    private command;
    constructor(options: FFmpegCommandWrapperOptions);
    getAvailableEncoders(): AvailableEncoders;
    getProfile(): string;
    getCommand(): ffmpeg.FfmpegCommand;
    debugLog(msg: string, meta: any): void;
    buildCommand(input: string): ffmpeg.FfmpegCommand;
    runCommand(options?: {
        silent?: boolean;
    }): Promise<void>;
    static resetSupportedEncoders(): void;
    getEncoderBuilderResult(options: EncoderOptionsBuilderParams & {
        streamType: 'video' | 'audio';
        input: string;
        videoType: 'vod' | 'live';
    }): Promise<{
        result: import("../models").EncoderOptions;
        encoder: string;
    }>;
    private checkFFmpegEncoders;
}
export {};
//# sourceMappingURL=ffmpeg-command-wrapper.d.ts.map